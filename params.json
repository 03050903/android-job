{"name":"Android-Job","tagline":"Android library to handle jobs in the background.","body":"# Overview\r\n\r\nAndroid provides three different APIs to run tasks in the future. All of them have their benefits and downsides. The AlarmManager’s API has [changed over time](https://plus.google.com/+AndroidDevelopers/posts/GdNrQciPwqo), so you need to be careful which method you use on which platform. The [JobScheduler](https://developer.android.com/reference/android/app/job/JobScheduler.html) is only available on Android Lollipop and Marshmallow, whereas the [GcmNetworkManager](https://developers.google.com/cloud-messaging/network-manager) is only available on devices with Google Play preinstalled.\r\n\r\nThere are three options with changing API levels, so it can be hard to know which one you need. You will also end up with many different paths in your code all doing the same for a different environment. We're open-sourcing this unified library to schedule jobs on Android. Depending on your requirements, this library decides which API suits your job. It provides a superset of all features from the existing AlarmManager, JobScheduler and GcmNetworkManager, e.g. you can run your job only if the device has a working Internet connection and is charging.\r\n\r\nSetting up the library is straightforward. You only need to initialize the JobManager and then you can start scheduling your jobs. You don’t need to declare any services, receivers or permissions in your manifest.\r\n\r\n# Download\r\n\r\nDownload [the latest version](http://search.maven.org/#search|gav|1|g:\"com.evernote\"%20AND%20a:\"android-job\") or grab via Gradle:\r\n\r\n```groovy\r\ndependencies {\r\n    compile 'com.evernote:android-job:1.0.3'\r\n}\r\n```\r\n\r\n# Usage\r\n\r\nThe class `JobManager` serves as entry point. Your jobs need to extend the class `Job`. Create a `JobRequest` with the corresponding builder class and schedule this request with the `JobManager`.\r\n\r\nBefore you can use the `JobManager` you must initialize the singleton. You need to provide a `Context` and add a `JobCreator` implementation after that. The `JobCreator` maps a job tag to a specific job class. It's recommend to initialize the `JobManager` in the `onCreate()` method of your `Application` object.\r\n\r\n```java\r\npublic class App extends Application {\r\n\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        JobManager.create(this).addJobCreator(new DemoJobCreator());\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class DemoJobCreator implements JobCreator {\r\n\r\n    @Override\r\n    public Job create(String tag) {\r\n        switch (tag) {\r\n            case DemoJob.TAG:\r\n                return new DemoJob();\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAfter that you can start scheduling jobs.\r\n\r\n```java\r\npublic class DemoJob extends Job {\r\n\r\n    public static final String TAG = \"job_demo_tag\";\r\n\r\n    @Override\r\n    @NonNull\r\n    protected Result onRunJob(Params params) {\r\n        // run your job\r\n        return Result.SUCCESS;\r\n    }\r\n}\r\n\r\nprivate void scheduleJob() {\r\n    new JobRequest.Builder(DemoJob.TAG)\r\n            .setExecutionWindow(30_000L, 40_000L)\r\n            .build()\r\n            .schedule();\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}